// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MMO_enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MMO_5fenum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MMO_5fenum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MMO_5fenum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MMO_5fenum_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MMO_5fenum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {
namespace mmo {

enum E_PacketID : int {
  ENTER_GAME_REQ = 0,
  ENTER_GAME_RESP = 1,
  OBJECT_ENTER_NOTIFY = 2,
  OBJECT_EXIT_NOTIFY = 3,
  MOVE_REQ = 4,
  MOVE_NOTIFY = 5,
  IDLE_REQ = 6,
  IDLE_NOTIFY = 7,
  NORMAL_ATTACK_REQ = 8,
  NORMAL_ATTACK_NOTIFY = 9,
  CHANGE_STATS_NOTIFY = 10,
  GET_EQUIPMENT_NOTIFY = 11,
  GET_CONSUME_NOTIFY = 12,
  USE_ITEM_REQ = 13,
  E_PacketID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_PacketID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_PacketID_IsValid(int value);
constexpr E_PacketID E_PacketID_MIN = ENTER_GAME_REQ;
constexpr E_PacketID E_PacketID_MAX = USE_ITEM_REQ;
constexpr int E_PacketID_ARRAYSIZE = E_PacketID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_PacketID_descriptor();
template<typename T>
inline const std::string& E_PacketID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_PacketID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_PacketID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_PacketID_descriptor(), enum_t_value);
}
inline bool E_PacketID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_PacketID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_PacketID>(
    E_PacketID_descriptor(), name, value);
}
enum E_RespCode : int {
  OK = 0,
  NO = 1,
  E_RespCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_RespCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_RespCode_IsValid(int value);
constexpr E_RespCode E_RespCode_MIN = OK;
constexpr E_RespCode E_RespCode_MAX = NO;
constexpr int E_RespCode_ARRAYSIZE = E_RespCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_RespCode_descriptor();
template<typename T>
inline const std::string& E_RespCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_RespCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_RespCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_RespCode_descriptor(), enum_t_value);
}
inline bool E_RespCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_RespCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_RespCode>(
    E_RespCode_descriptor(), name, value);
}
enum E_ObjectState : int {
  NONE = 0,
  IDLE = 1,
  MOVE = 2,
  ATTACK = 3,
  DEAD = 4,
  E_ObjectState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_ObjectState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_ObjectState_IsValid(int value);
constexpr E_ObjectState E_ObjectState_MIN = NONE;
constexpr E_ObjectState E_ObjectState_MAX = DEAD;
constexpr int E_ObjectState_ARRAYSIZE = E_ObjectState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_ObjectState_descriptor();
template<typename T>
inline const std::string& E_ObjectState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_ObjectState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_ObjectState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_ObjectState_descriptor(), enum_t_value);
}
inline bool E_ObjectState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_ObjectState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_ObjectState>(
    E_ObjectState_descriptor(), name, value);
}
enum E_Dir : int {
  RIGHT = 0,
  UP = 1,
  LEFT = 2,
  BOTTOM = 3,
  DIR_MAX = 4,
  E_Dir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Dir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Dir_IsValid(int value);
constexpr E_Dir E_Dir_MIN = RIGHT;
constexpr E_Dir E_Dir_MAX = DIR_MAX;
constexpr int E_Dir_ARRAYSIZE = E_Dir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Dir_descriptor();
template<typename T>
inline const std::string& E_Dir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Dir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Dir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Dir_descriptor(), enum_t_value);
}
inline bool E_Dir_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Dir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Dir>(
    E_Dir_descriptor(), name, value);
}
enum E_KeyCode : int {
  Q = 0,
  W = 1,
  E = 2,
  R = 3,
  E_KeyCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_KeyCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_KeyCode_IsValid(int value);
constexpr E_KeyCode E_KeyCode_MIN = Q;
constexpr E_KeyCode E_KeyCode_MAX = R;
constexpr int E_KeyCode_ARRAYSIZE = E_KeyCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_KeyCode_descriptor();
template<typename T>
inline const std::string& E_KeyCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_KeyCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_KeyCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_KeyCode_descriptor(), enum_t_value);
}
inline bool E_KeyCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_KeyCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_KeyCode>(
    E_KeyCode_descriptor(), name, value);
}
enum E_ObjectType : int {
  OBJECT_TYPE_NULL = 0,
  PLAYER = 1,
  MONSTER = 2,
  SKILL_OBJECT = 4,
  ITEM = 8,
  E_ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_ObjectType_IsValid(int value);
constexpr E_ObjectType E_ObjectType_MIN = OBJECT_TYPE_NULL;
constexpr E_ObjectType E_ObjectType_MAX = ITEM;
constexpr int E_ObjectType_ARRAYSIZE = E_ObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_ObjectType_descriptor();
template<typename T>
inline const std::string& E_ObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_ObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_ObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_ObjectType_descriptor(), enum_t_value);
}
inline bool E_ObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_ObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_ObjectType>(
    E_ObjectType_descriptor(), name, value);
}
enum E_SkillType : int {
  INSTANT_TARGET_BASED = 0,
  INSTANT_LOCATION_BASED = 1,
  PERSISTENT_TARGET_BASED = 2,
  PERSISTENT_LOCATION_BASED = 3,
  E_SkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_SkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_SkillType_IsValid(int value);
constexpr E_SkillType E_SkillType_MIN = INSTANT_TARGET_BASED;
constexpr E_SkillType E_SkillType_MAX = PERSISTENT_LOCATION_BASED;
constexpr int E_SkillType_ARRAYSIZE = E_SkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_SkillType_descriptor();
template<typename T>
inline const std::string& E_SkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_SkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_SkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_SkillType_descriptor(), enum_t_value);
}
inline bool E_SkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_SkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_SkillType>(
    E_SkillType_descriptor(), name, value);
}
enum E_CCType : int {
  STUN = 0,
  NO_POTION = 1,
  NO_SKILL = 2,
  E_CCType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_CCType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_CCType_IsValid(int value);
constexpr E_CCType E_CCType_MIN = STUN;
constexpr E_CCType E_CCType_MAX = NO_SKILL;
constexpr int E_CCType_ARRAYSIZE = E_CCType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_CCType_descriptor();
template<typename T>
inline const std::string& E_CCType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_CCType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_CCType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_CCType_descriptor(), enum_t_value);
}
inline bool E_CCType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_CCType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_CCType>(
    E_CCType_descriptor(), name, value);
}
enum E_Stats : int {
  MAX_HP = 0,
  MAX_MP = 1,
  HP = 2,
  MP = 3,
  ATK = 4,
  DEF = 5,
  E_Stats_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Stats_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Stats_IsValid(int value);
constexpr E_Stats E_Stats_MIN = MAX_HP;
constexpr E_Stats E_Stats_MAX = DEF;
constexpr int E_Stats_ARRAYSIZE = E_Stats_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Stats_descriptor();
template<typename T>
inline const std::string& E_Stats_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Stats>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Stats_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Stats_descriptor(), enum_t_value);
}
inline bool E_Stats_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Stats* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Stats>(
    E_Stats_descriptor(), name, value);
}
enum E_Equipment : int {
  HELMET = 0,
  ARMOR = 1,
  GLOVES = 2,
  WEAPON = 3,
  RING = 4,
  SHOES = 5,
  EQUIP_MAX = 6,
  E_Equipment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Equipment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Equipment_IsValid(int value);
constexpr E_Equipment E_Equipment_MIN = HELMET;
constexpr E_Equipment E_Equipment_MAX = EQUIP_MAX;
constexpr int E_Equipment_ARRAYSIZE = E_Equipment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Equipment_descriptor();
template<typename T>
inline const std::string& E_Equipment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Equipment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Equipment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Equipment_descriptor(), enum_t_value);
}
inline bool E_Equipment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Equipment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Equipment>(
    E_Equipment_descriptor(), name, value);
}
enum E_TargetBasedActionType : int {
  CHANGE_STATS = 0,
  BUFF = 1,
  CROWD_CONTROL = 2,
  PERSISTENT_CHANGE_STATS = 3,
  E_TargetBasedActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_TargetBasedActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_TargetBasedActionType_IsValid(int value);
constexpr E_TargetBasedActionType E_TargetBasedActionType_MIN = CHANGE_STATS;
constexpr E_TargetBasedActionType E_TargetBasedActionType_MAX = PERSISTENT_CHANGE_STATS;
constexpr int E_TargetBasedActionType_ARRAYSIZE = E_TargetBasedActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_TargetBasedActionType_descriptor();
template<typename T>
inline const std::string& E_TargetBasedActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_TargetBasedActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_TargetBasedActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_TargetBasedActionType_descriptor(), enum_t_value);
}
inline bool E_TargetBasedActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_TargetBasedActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_TargetBasedActionType>(
    E_TargetBasedActionType_descriptor(), name, value);
}
enum E_ItemType : int {
  EQUIPMENT = 0,
  CONSUME = 1,
  E_ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_ItemType_IsValid(int value);
constexpr E_ItemType E_ItemType_MIN = EQUIPMENT;
constexpr E_ItemType E_ItemType_MAX = CONSUME;
constexpr int E_ItemType_ARRAYSIZE = E_ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_ItemType_descriptor();
template<typename T>
inline const std::string& E_ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_ItemType_descriptor(), enum_t_value);
}
inline bool E_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_ItemType>(
    E_ItemType_descriptor(), name, value);
}
enum E_QuestTaskType : int {
  KILL_MONSTER = 0,
  COLLECT_ITEM = 1,
  E_QuestTaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_QuestTaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_QuestTaskType_IsValid(int value);
constexpr E_QuestTaskType E_QuestTaskType_MIN = KILL_MONSTER;
constexpr E_QuestTaskType E_QuestTaskType_MAX = COLLECT_ITEM;
constexpr int E_QuestTaskType_ARRAYSIZE = E_QuestTaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_QuestTaskType_descriptor();
template<typename T>
inline const std::string& E_QuestTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_QuestTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_QuestTaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_QuestTaskType_descriptor(), enum_t_value);
}
inline bool E_QuestTaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_QuestTaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_QuestTaskType>(
    E_QuestTaskType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace mmo
}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::mmo::E_PacketID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_PacketID>() {
  return ::protocol::mmo::E_PacketID_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_RespCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_RespCode>() {
  return ::protocol::mmo::E_RespCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_ObjectState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_ObjectState>() {
  return ::protocol::mmo::E_ObjectState_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_Dir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_Dir>() {
  return ::protocol::mmo::E_Dir_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_KeyCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_KeyCode>() {
  return ::protocol::mmo::E_KeyCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_ObjectType>() {
  return ::protocol::mmo::E_ObjectType_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_SkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_SkillType>() {
  return ::protocol::mmo::E_SkillType_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_CCType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_CCType>() {
  return ::protocol::mmo::E_CCType_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_Stats> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_Stats>() {
  return ::protocol::mmo::E_Stats_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_Equipment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_Equipment>() {
  return ::protocol::mmo::E_Equipment_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_TargetBasedActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_TargetBasedActionType>() {
  return ::protocol::mmo::E_TargetBasedActionType_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_ItemType>() {
  return ::protocol::mmo::E_ItemType_descriptor();
}
template <> struct is_proto_enum< ::protocol::mmo::E_QuestTaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::mmo::E_QuestTaskType>() {
  return ::protocol::mmo::E_QuestTaskType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MMO_5fenum_2eproto
